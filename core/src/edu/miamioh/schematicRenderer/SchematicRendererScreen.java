package edu.miamioh.schematicRenderer;

import org.antlr.v4.runtime.tree.ParseTree;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Stage;

/**
 * @author bdshaffer73
 */
public class SchematicRendererScreen implements Screen {
    
    private static SchematicRendererScreen schematicRendererScreen;
    private SchematicRenderer		   schematic;
    private SchematicRendererController	   controller;
    private Stage			   schematicStage;
    
    /**
     * Creates a SchematicRenderer Screen.
     */
    public SchematicRendererScreen() {
	controller = new SchematicRendererController();
	schematic = new SchematicRenderer();
	schematicRendererScreen = this;
    }
    
    // Public methods
    
    /**
     * Sets the root module tree to the one currently being edited.
     * 
     * @param root_tree A ParseTree generated by the current Verilog file.
     */
    public void setRoot_tree(ParseTree root_tree) {
	schematic.setRoot_tree(root_tree);
	if (schematic.getRoot_tree() == null) {
	    System.out.println("The root_tree has been set to null.");
	} else {
	    System.out.println("The root_tree has successfully been set.");
	}
    }
    
    /**
     * Gets the compilation status of the schematic.
     * 
     * @return True if schematic.getData() has run on a valid root_tree;
     */
    public boolean schematic_is_Compiled() {
	return this.schematic.is_Compiled();
    }
    
    /**
     * Compiles the data so that the SchematicRenderer can render the schematic.
     */
    public void compile() {
	if (schematic.getRoot_tree() != null) {
	    schematic.clearData();
	    schematic.getData();
	}
    }
    
    @Override
    public void show() {
	controller.updateConfig();
	schematicStage = new BackStage().getStage();
    }
    
    /**
     * This method draws a new window with the schematic design determined by
     * the Verilog logic.
     */
    @Override
    public void render(float arg0) {
	
	Gdx.gl.glClearColor(255, 255, 255, 1);
	Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
	
	schematic.render(schematicStage);
	
	schematicStage.act(Gdx.graphics.getDeltaTime());
	schematicStage.draw();
	
    }
    
    /**
     * Called when the {@link Application} is resized. This can happen at any
     * point during a non-paused state but will never happen before a call to
     * create().
     *
     * @param width
     *            the new width in pixels
     * @param height
     *            the new height in pixels
     */
    @Override
    public void resize(int width, int height) {
	
	controller.updateConfig();
	
	schematicStage = new BackStage().getStage();
	
	controller.updateInputProcessor(schematicStage);
	
    }
    
    /**
     * Called when the {@link Application} is paused, usually when it's not
     * active or visible on screen. An Application is also paused before it is
     * destroyed.
     */
    @Override
    public void pause() {
    }
    
    /**
     * Called when the {@link Application} is resumed from a paused state,
     * usually when it regains focus.
     */
    @Override
    public void resume() {
    }
    
    /**
     * Releases all resources of this object.
     */
    @Override
    public void dispose() {
	schematic.dispose();
    }
    
    @Override
    public void hide() {
    }
    
    // Package methods
    
    static SchematicRendererScreen getScreen() {
	return schematicRendererScreen;
    }
    
}
